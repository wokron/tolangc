# 中间代码生成 - Pcode

### 一、pcode介绍

pcode源于Pascal编译器产生的基于栈式虚拟机的中间代码。尽管中间代码（如四元式等）通常与机器无关，但是由于pcode是基于栈式虚拟机的，因此在生成pcode时必须考虑栈式虚拟机的一些特性，以及运行时的内存管理等。我们首先简单介绍关于栈式虚拟机的一些基本知识。

#### （一）栈式虚拟机的工作过程

栈式虚拟机可以理解为一个解释执行程序（如python解释器），它能够执行输入的pcode代码并产生相应的结果。

和我们学过的MIPS架构不同，栈式虚拟机中没有众多寄存器用于保存运算结果或变量（如MIPS中的`$t`寄存器和`$s`寄存器等），只有5个基本的寄存器，而且这些寄存器有特殊用途，不能用来保存运算结果。这就意味着变量、中间结果等都必须保存在内存的数据区中。

此外，栈式虚拟机的最大特点，就在于其将内存的数据区视为一个栈，大量的运算都是针对栈顶的入栈、退栈、计算来完成的，内存的动态管理也是基于栈的。例如，对于下列代码

```
int a = 1;
printf("%d", (a+2)*3);
```

<img src="..\..\figure\stack.png" alt="./figure/stack.png" style="zoom: 67%;" />

栈式虚拟机的栈变化如上图所示（黄色为栈顶，蓝色为次栈顶）：

1. 为变量a分配内存空间，并初始化
2. 栈顶压入变量a的值（为1）
3. 栈顶压入常数2
4. 栈顶与次栈顶相加，弹出两个元素，并压入运算结果（为3）
5. 栈顶压入常数3
6. 栈顶与次栈顶相乘，弹出两个元素，并压入运算结果（为9）
7. 弹出栈顶，并输出其值（输出9）

可以看到，在栈式虚拟机中，变量都保存在内存中，运算的中间结果也保存在内存中，且操作都是基于栈结构进行的。

#### （二）栈式虚拟机的5个寄存器

栈式虚拟机中只有5个寄存器：PC、SP、MP、NP、EP。这里简单介绍每个寄存器的作用：

- PC：程序计数器，和MIPS中的PC相同，指向下一条将要执行的指令
- SP：栈指针，指向栈顶，便于入栈退栈
- MP：标志指针，指向当前活动记录基地址（活动记录后续会介绍）
- NP：堆指针，指向空闲堆空间起始位置
- EP：顶指针，指向当前程序模块在栈中的最高位置

其中，由于我们的文法不涉及内存的运行时分配（如`new()`），因此实现的栈式虚拟机不需要堆区，也不需要NP寄存器；且可以假定栈式虚拟机有无限大的内存空间，因此也不需要EP寄存器来防止栈溢出。所以，我们真正需要实现的只有PC、SP和MP三个寄存器。

### 二、动态内存管理

在正式介绍pcode代码之前，先了解一下动态内存管理的一些知识。

#### （一）静态与动态

内存管理是编译过程中一个非常重要的过程。其中，最大的难点在于，分程序结构在编译时程序是静态的，而程序运行时却是动态的，因此，我们在编译时不可能完全确定好内存的分配。例如以下代码：

```c
int fibo(int n) {
	if(n <= 1) return 1;
	int x = fibo(n-1);
	int y = fibo(n-2);
	return x+y;
}

int main() {
	int n;
	n = getint();
	n = fibo(n);
	printf("%d",n);
	return 0;
}
```

程序运行时，每次调用`fibo()`都要分配一块内存空间（至少需要为变量n、x、y分配内存空间），但是在编译时，我们并不能确定输入的n是多少，也就无法确定`fibo()`会被调用多少次，无法确定需要分配多少的内存空间。除了内存的分配，内存的访问（如数组存取）同样存在上述问题。

在编译的过程中实现内存的动态管理的一个重要方法是活动记录。接下来我们详细介绍基于活动记录的动态内存管理。

#### （二）活动记录

活动记录Activity Record（AR）一般指一个过程一次执行所需的内存信息。其中，在sysY文法中，过程可以简单理解为一个block。也就是说，在每次执行一个block时，我们都会为其分配一块内存区域，这块区域用于分配变量、保存临时结果、保存运行时状态等信息，称为活动记录。

<img src="..\..\figure\AR.png" alt="./figure/stack.png" style="zoom: 67%;" />

在栈式虚拟机中，一个活动记录主要包含以下几种数据：

- 返回值，表示该过程执行结束的返回值，可以理解为函数返回值
- 返回地址，表示该过程执行结束后应该返回的指令地址，类似MIPS中`$ra`寄存器的作用
- 静态链Static Link（SL），指向外层活动记录的基地址，可以理解为当前block外层的block的AR基地址。其“静态”体现在可以根据程序源代码直接确定block之间的嵌套关系。
- 动态链Dynamic Link（DL），指向调用者的活动记录的基地址。其“动态”体现在编译时无法确定被谁调用，只有运行时才能确定。
- 参数区，调用过程（函数）时用于传递参数，类似MIPS中`$a`寄存器的作用
- 数据区，包括局部数据区和临时变量区。其中，局部数据区存储定义的局部变量，临时变量区存储运算的中间结果等。

接下来我们重点分析AR中的静态链和动态链的作用。

#### （三）静态链SL

静态链的值是外层活动记录的基地址，作用主要是进行不同作用域下的变量访问。

对于如下代码：

```c
int main() {				// block1
	int a = 10, b = 20;
	if(a < b) {				// block 2
		int a = 0;			// 覆盖block1中a的定义
		while (a < 10) {	// block 3
			b = b + 1;		// 引用的block1的b  -------------------------1
			a = a + 1;		// 引用的block2的a  -------------------------2
		}
	}
	printf("%d",b);
	return 0;
}
```

根据静态的程序，如注释所示，我们可以确定三个block之间的嵌套关系，以及每个变量定义的作用域。

如下图所示，在程序执行到block3时，内层中存在3个AR，对应三个block。图中只简单画出了AR的局部变量区和静态链SL，黑色加粗表示AR基地址。

<img src="..\..\figure\static_link.png" alt="./figure/stack.png" style="zoom: 67%;" />

在程序执行到block3中的1处时，此时需要引用变量b，但是变量b在当前AR（AR3）中并没有定义，因此通过SL3找到AR2，发现在AR2中也没有变量b的定义，再次通过SL2找到AR1，在AR1中发现了变量b的定义。事实上，从源程序中也可以发现，引用的确实是block1定义的变量b。在执行到2处时，引用变量a，类似上面的过程，在AR2中找到变量a的定义，说明引用的是此处的变量a。上述过程说明，我们只要沿着静态链找，找到的第一个定义点，就是对应的变量定义。

在这里，我们定义两个重要概念：level和addr。level表示活动记录的深度，例如处于AR3中时，变量a的level为1（通过一次静态链搜索即可在AR2中找到定义），变量b的level为2（通过2次静态链搜索在AR1中找到定义）。addr表示变量与其定义AR的基地址的相对偏移。有了这两个概念，我们就可以很方便地来跨活动记录访问变量。例如，当前处于AR3，要访问变量b，则变量b的level为2，通过2次静态链搜索，找到AR1的基地址，再加上变量b的addr（距离基地址的相对偏移），即可确定变量b的绝对地址，访问变量b。

因此，在编译生成代码时，我们对变量的访问只需要给出level和addr两个值即可。注意，**level、addr的值在编译时是可以通过符号表确定的**，其中level可以根据block的相互嵌套关系（或符号表的深度）确定，addr则可以根据该block内的变量大小和数量确定，这也是“静态”的一种体现。

在上面的例子中，我们似乎可以直接确定变量a和变量b的绝对地址，甚至不用通过level、addr和静态链来访问。但是，对于更复杂的情况，如递归调用（`fibo(n)`），编译时，我们无法确定当前是第几次调用，也就无法确定AR的基地址（因为每次调用都要分配一个AR），无法通过绝对地址来访问，但可以通过相对的level和addr来访问。这也是静态链的必要性所在。

#### （四）动态链

动态链的作用主要是在函数调用完成后，能够使标志指针MP回到调用前的状态（指向调用者的AR基地址）。因此，调用者在调用函数时，需要将当前MP的值填入函数AR的DL中，函数执行完毕后，将DL的值赋给MP。由于编译时无法预知调用者的AR基地址，因此DL的值在编译时无法确定，只能在程序运行过程中再填入。

最后，建议在实现的过程中，按前面提到的AR结构来实现，预留出返回值、返回地址、SL、DL等区域（即使有些时候不需要），确保AR结构统一。

### 三、Pcode代码介绍

在了解完栈式虚拟机和基于活动记录的动态内存管理后，我们正式介绍pcode代码。pcode代码围绕栈式虚拟机的特点，其操作主要针对栈来进行。下面给出一些供参考的pcode代码，当然你也可以根据自己的需要来自行设计代码。

| 指令名称 | 指令格式        | 说明                                                         |
| -------- | --------------- | ------------------------------------------------------------ |
| LIT      | LIT imm         | 加载立即数imm到栈顶                                          |
| OPR      | OPR opcode      | 进行栈顶与次栈顶（或者单独栈顶）的运算，并将结果压入栈顶；opcode决定运算类型 |
| LOD      | LOD level, addr | 以栈顶元素为动态偏移，加载内存中`(level, addr)+动态偏移`处的变量值到栈顶 |
| STO      | STO level, addr | 以栈顶元素为动态偏移，把次栈顶的元素写入内存中`(level, addr)+动态偏移`处的变量 |
| CAL      | CAL label       | 函数调用（分配AR、设置SL、DL、参数等）                       |
| BLKS     | BLKS            | 开启新的block（分配新的AR，设置SL、DL等）                    |
| BLKE     | BLKE level      | 结束当前block（回收当前AR）                                  |
| JMP      | JMP label       | 无条件跳转到label                                            |
| JPC      | JPC label       | 栈顶为0时跳转到label，否则顺序执行                           |
| JPT      | JPT label       | 栈顶不为0时跳转到label，否则顺序执行                         |
| INT      | INT imm         | 栈顶寄存器加imm，用于控制栈顶指针的移动                      |
| RED      | RED             | 读入数字到栈顶                                               |
| WRT      | WRT             | 输出栈顶数字                                                 |
| WRTS     | WRTS str        | 输出字符串                                                   |
| LABLE    | label:          | 标识label，用于跳转                                          |
| RET      | RET             | 返回调用者并回收AR                                           |
| LEA      | LEA level, addr | 加载(level, addr)处变量的绝对地址到栈顶                      |

下面对生成上述代码中的一些注意事项进行讲解。

#### （一）内存访问：LOD与STO

前面我们提到，通过level和addr，即可对内存中的变量进行存取。但是为什么在LOD和STO指令中，我们还需要以栈顶值为动态偏移呢？考虑下面的例子

```c
int main() {
	int arr[4] = {1,2,3,4};
	int i;
    i = getint();
	i = i % 4;
	printf("%d",arr[i]);  // ----------------- 1
	return 0;
}
```

尽管我们知道变量arr的(level, addr)，但是由于变量i的值在编译时无法确定，因此需要在运行时将变量i的值加载到栈顶作为动态偏移，再和(level, addr)配合进行数组元素的访问。

其中，1处输出arr[i]的pcode代码示例如下

```
LIT 0
LOD 0, 8	// 加载i到栈顶 i在当前AR中定义，level=0，addr=8，动态偏移为0
LOD 0, 4	// 加载arr[i]到栈顶，arr的level=0， addr=4，动态偏移为栈顶的i
WRT		// 输出arr[i]
```

#### （二）Block与AR：BLKS和BLKE

在sysY文法中，进入一个block相当于进入一个新的过程，需要分配一个活动记录AR；而从一个block退出时，也需要回收其AR。

需要注意的是，对于AR的分配，编译的时候，只需要生成BLKS指令即可，不必填充AR中的SL、DL（编译时也无法确定）；栈式虚拟机在解释执行BLKS指令时，会分配AR并填充上述字段。

通常来说，对于每个block，block的开始通过BLKS（block start）指令分配AR，结束时通过BLKE（block end）指令回收AR。但是，还需要考虑下面几种特殊情况：

```c
int func(int a, int b) {  // 函数AR
	int x = a + b;
	if(x < 10) {
		int y = x * a;
		if(y < 10) {
			return y;	// ---------------------1
		}
	}
	return 0;
}
```

在如上的函数中，执行到1处时，分配了3个AR，在执行return返回调用者时，需要一次性回收这三个AR。

```c
int main() {
	int i = 10;
	while(i > 0) { // 循环AR
		int a;
		a = getint();
		if(a < 10) {
			int b = a + i;
			if(b > 10) {
                break; // -----------------1
            }
		}
		i = i - 1;
	}
    return 0;
}
```

在如上代码中，进入循环后，执行到1处break时，需要回收循环体的三个AR。（continue同理）

对于这两种情况，建议在编译过程中记录函数定义block和循环block的深度，在遇到return/break/continue时，通过block深度确定需要回收多少个AR，从而在return/break/continue之前生成多少条BLKE指令。

此外，还需要考虑以下隐式block的情况。

```c
int ga = 0;

int add() {
	ga = ga + 1;
	return ga;
}

int main() {
    int b = 10;
	while(ga < 10) int a = 3 + add(); // ----------1
	return 0;
}
```

虽然没有显式定义block，但是1处依然要分配新的AR，因此对于这种情况，可以按照定义了block处理。

#### （三）传地址的数组存取

在函数中，可能涉及到传地址参数，并以此来进行数组的存取。例如下面例子：

```c
void func(int arr[], int i) {
	printf("%d",arr[i]);
}

int main() {
	int arr[4] = {1,2,3,4};
	func(arr,2);
	return 0;
}
```

对于这种情况，建议先读取形参的值作为绝对基地址（图a），然后由绝对基地址+偏移值得到绝对地址存储在栈顶，来进行绝对寻址（图c）。注意，在绝对地址寻址时，可以将LOD/STO指令中的level和addr设置为特殊值以示区分。

<img src="..\..\figure\abs_addr.png" alt="./figure/stack.png" style="zoom: 67%;" />

给出上面例子中`func()`一种供参考的生成的pcode代码

```
INT 1 // 为形参arr分配空间（参数的值已经由调用者设置好）
INT 1 // 为形参i分配空间（参数的值已经由调用者设置好）
LIT 0
LOD 0, 4 // 加载参数arr的值（level为0，addr为4，动态偏移栈顶为0）
LIT 0
LOD 0, 5 // 加载参数i的值（level为0，addr为5，动态偏移栈顶为0）
OPR 1 // 栈顶与次栈顶相加 得到绝对地址压入栈顶
LOD -1, 0 // 按栈顶绝对地址寻址 level设为-1 addr设为0 表示按栈顶存储的绝对地址寻址
WRT // 输出栈顶元素
RET
```

### 四、Pcode解释执行程序

除了pcode代码生成，还需要完成一个栈式虚拟机来解释执行生成的pcode。该栈式虚拟机需要包括：代码区（用于存储pcode代码），数据区（栈），三个寄存器（PC、MP、SP）。大部分指令的解释执行只需要按其对栈的操作进行实现即可，这里主要介绍一下函数调用和返回的解释执行过程。

函数调用（CAL指令）的执行过程包括：

1. 准备好若干个参数，存储在栈顶。
2. 为函数分配AR，并设置返回地址，SL（为全局变量所在的AR的基地址），DL（为调用者AR基地址，存储在MP中），参数。其中，实参原本在调用者的栈顶，需要复制到函数AR的参数区，之后函数只需要通过INT指令来为形参分配空间即可（参数值已经在参数区中存好了）。建议函数AR的起始可以直接覆盖栈顶实参，完成参数从调用者AR退栈的操作。
3. 分配好AR后，将MP设置为新的AR的基地址，栈顶指针SP指向参数区起始位置。
4. 设置PC为函数入口指令地址。

其中，第1、2步和BLKS的解释执行过程较为类似。

函数返回（主要是RET指令、BLKE指令）的执行过程包括：

1. 如果有返回值，将返回值填入函数第一个AR的返回值区域。注意，return语句可能出现在函数体中的任一个block，但是返回值建议填入函数的第一个AR（也就是CAL指令分配的AR）。
2. 回收所有函数AR（可以通过若干BLKE指令来回收）。
3. 恢复PC（返回地址）、SP（函数第一个AR基地址-1，刚好指向调用者栈顶）、MP（动态链）。如果有返回值，则执行INT 1指令，使SP+1，此时返回值正好处于调用者栈顶。

以下面这个简单的例子为例来进行具体说明：

```
int add(int a, int b, int c) {
	int r = a + b + c;
	return r;
}

int main() {
	int r = add(1,2,3);
	printf("%d",r);
	return 0;
}
```

<img src="..\..\figure\call_ret.png" alt="./figure/stack.png" style="zoom: 67%;" />

- 图（a）：main中准备好三个参数，存储在栈顶，准备调用add()
- 图（b）：执行CAL指令，为函数分配AR，设置返回地址、SL、DL，同时把参数填入到参数区，更新PC、SP、MP寄存器。注意，分配的AR可以直接覆盖原本栈顶的参数。
- 图（c）：add()中计算完结果，把结果填入AR中的返回值，准备返回
- 图（d）：执行RET指令，回收CAL分配的AR，恢复PC、SP、MP寄存器。由于有返回值，sp+1，使得返回值6刚好在栈顶，便于后续操作。

