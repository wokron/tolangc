# 词法分析

### 一、词法分析概述

#### （一）编译器输入源程序

在介绍词法分析之前，我们先了解一下输入编译器的源程序实际上是什么形式。从人的角度看，源程序可以带有各种结构，如顺序结构、分支结构等等，而且我们还可以通过空格、换行等来把一个个单词清晰地分开。但是从编译器的角度看，源程序仅仅是一个**线性的字符串**。

例如对于下面这个简单的分支结构源程序：

```c
int main() {
	int var = 8+2;
	if (var != 10) {
		printf(“error!”);
	}
	else {
		printf(“correct!”);
	}
	return 0;
}
```

对于编译器而言，输入的是这样一个字符串：

```
int main() {\n\tint var = 8+2;\n\tif (var != 10) {\n\t\tprintf(“error!”);\n\t}\n\telse {\n\t\tprintf(“correct!”);\n\t}\n\treturn 0;\n}
```

这个字符串是由一个个字符组成的连续序列，不具有其他复杂结构。这样一个非结构化的线性字符串对于编译器后续的分析工作是十分不利的，因此，编译器的第一步就是要把这样一个线性字符串分割成一个个单词，便于后续分析。

#### （二）词法分析器的作用

词法分析器作为编译器的第一部分，承担的任务就是**通过扫描输入的源程序字符串，将其分割成一个个单词，同时记录这些单词的类别信息**。而对于源程序中一些对编译没用的符号，如'\n'和注释等，词法分析器也会进行适当的处理（如忽视跳过，记录当前行号等）。

<img src="..\..\figure\lexer_1.png" alt="lexer_1" style="zoom:40%;" />

如图所示，经过词法分析器的解析，我们就可以从词法分析器依次获取每个单词的信息，包括单词值和单词类别，用于后续的编译。

需要注意的是，词法分析器只负责单词的划分解析，不涉及具体的语法和语义判断。

### 二、词法分析实现思路

#### （一）词法分析器的工作过程

在了解了词法分析器的作用后，我们来进一步学习词法分析器的工作过程。

一般而言，词法分析器包含以下部分：

- 源程序字符串`source`：输入编译器的源程序字符串
- 位置指针`p`：指向**下一个待解析的单词的起始字符**，初始化时指向source的第一个字符
- 单词值`token`：解析的单词值，为字符串
- 单词类别`type`：解析的单词类别，枚举类型
- 行号`line`：当前解析位置在源程序中的行号
- 数值`number`：解析的单词如果为数字（该单词本身是一个字符串），则设置number为该单词表示的数值
- `next`：词法分析器对外提供的接口，用于进行一次解析

此外，也可以根据实际需要额外添加其他部分。下面我们来看词法分析器大致的工作过程（黄色部分为本次解析的部分，灰色部分为已经解析完成的部分）。



<img src="..\..\figure\lexer_2.png" alt="lexer_2" style="zoom:40%;" />

1. 初始化时，**`p`指向`source`的第一个字符**，`line=1`，其他部分为空。
2. 解析第一个单词"int"，并设置`token`和`type`为相应的单词值和单词类别，**`p`指向下一个待解析的单词的初始字符**。
3. **跳过空格字符**，解析第二个单词"main"，并设置`token`和`type`为相应的单词值和单词类别。
4. 经过若干步后，跳过"\\n\\t"并**`line`加1**，解析单词"int"，并设置`token`和`type`为相应的单词值和单词类别。
5. 经过若干步后，跳过空格字符，解析单词"10"，设置`token`和`type`为相应的单词值和单词类别，同时设置`number=10`。
6. 解析最后一个单词";"，设置`token`和`type`为相应的单词值和单词类别，解析结束。

编译器的其他部分通过每次调用`next`来解析一个单词，并通过`token, type, line, number`来获取本次解析得到的单词的相关信息。其中，最为重要的是每次调用`next`时，如何解析出一个单词（即图中的黄色部分）。下面介绍这一部分常用的方法——有限自动机。

#### （二）有限状态自动机

有限状态自动机FSA是处理形式化语言的重要工具，常常用于识别特定模式的字符串。有限状态自动机FSA内部包含一个当前状态$q$和转移函数$δ$，对于一个输入的字符$a$，FSA将根据当前状态$q$和字符$a$转移到下一个状态$p$，即有$p=δ(q,a)$。

这里用一个简单的例子来说明FSA的工作流程。

<img src="..\..\figure\lexer_3.png" alt="lexer_3" style="zoom:40%;" />

上图是一个用于识别"hello"和"here"两个单词的FSA，初始时FSA处于起始状态$q_0$，后续每读入一个字符$a$，都将根据当前状态和$a$进行一次状态转移（即沿着图中的对应边进入下一个状态），在到达$q_5$或$q_7$后，FSA就成功识别了一个"hello"或"here"单词。需要注意的是，在读入"he"时，我们不能判断当前这个单词是"hello"还是"here"，需要根据读入的下一个字符进行判断并转移到不同的状态分支（对应图中的$q_2$）。此外，这个例子也没有考虑异常情况，如读入字符'z'。

那么，FSA和我们的词法分析器有什么关系呢？不难发现，词法分析的单词中，很多都具有特定的结构：保留字和许多运算符号具有固定的字符串值，如main，break，+，&&，这些固定的串值可以通过类似上面例子的FSA识别；标识符和常数具有规定的结构，如标识符由一个字母或下划线开始，后面跟若干个字母或数字或下划线（如_a1_2b3），而常数则由数字开始，后面跟若干个数字（如123），虽然它们没有固定的串值，但是也可以通过FSA来进行识别。例如，下图是一个识别标识符的FSA。

<img src="..\..\figure\lexer_4.png" alt="lexer_4" style="zoom:40%;" />

因此，我们完全可以对每种单词都构造一个小的FSA，最后再将它们合成一个大的FSA，帮助我们的词法分析器识别所有的单词。

但是，在实际实现的过程中，为每种单词都构造一个FSA并最终将它们合并，将会产生数量巨大的中间状态和状态转移，这是十分繁琐且没有必要的。这里给出一种简单的基于贪心策略的实现方法，这种方法通过”贪心“地读取一串字符来简化许多繁琐的状态转移。

1. 每次调用next时，词法分析器先跳过当前位置的所有空白符，如果有'\n'则行号加1. 如果当前位置有注释，则跳过。
2. 如果当前字符是字母或下划线，则继续往后读取一串由字母或下划线或数字组成的字符串，直到结束或遇到不是这三者的字符，然后对于刚刚读取的这个字符串，到保留字表中进行查询，如果这个字符串属于保留字，如int，则按对应的保留字处理，否则按标识符处理。
3. 如果当前字符是数字，则继续往后读取一串由数字组成的字符串，直到结束或遇到非数字字符，然后按常数来处理刚刚读取的这个字符串。
4. 对于剩下的符号，如+,(等，只需要进行一次简单的判断即可。

事实上，可以发现前面词法分析器工作过程的例子正是按照这种方式来解析单词的。

#### （三）注意事项

注释对于后续的编译过程没有任何影响，因此应该在词法分析阶段就过滤掉。我们需要考虑的注释有两种，一种是单行注释，一种是多行注释。

```c
// 这是一个单行注释
/* 这是一个
	多行注释 */
```

对于单行注释而言，一旦识别到"//"，则后面的内容全部跳过，直到遇到换行符；对于多行注释而言，一旦识别到"/\*"，则到下一个"\*/"中间的内容都要跳过。这里需要特别注意如下几种情况：

```c
/* ***** 这是一个注释 ****123/ **** 
********* 4/2 */

/* 这也是一个//注释  */

// /* 这还是一个注释 */ 

int a = 2048 / /* 这依然是一个注释 */ 1024; // 注意不要把除号当成注释
```

此外，我们会发现单词中有一些单词存在前缀重叠的情况，如'<'和'<='，对于这些前缀重叠的单词，我们单单读入一个符号是无法判断的，因此需要”偷看“下一个字符来判断是哪一种单词。

#### （四）词法错误

一个完整的编译器，除了能够编译出正确的目标代码，还需要能够对各种错误进行识别和检测。在词法分析阶段，我们可以完成部分词法错误的识别，当遇到下列错误时，你的编译器需要报错。请你完成这部分的错误处理后提交到错误处理部分的对应题目中，具体要求可参考错误处理作业。此外，你的编译器需要保持错误处理的功能，在后续测试中可能同时出现正确和错误样例，都需要能够处理。

| 错误类型 | 错误类别码 | 解释                                                         | 对应文法                            |
| -------- | ---------- | ------------------------------------------------------------ | ----------------------------------- |
| 非法符号 | a          | 格式字符串中出现非法字符，如&等，报错行号为**\<FormatString\>**所在行数。 | \<FormatString\> → ‘“‘{\<Char\>}’”’ |
