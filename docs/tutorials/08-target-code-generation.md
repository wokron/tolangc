# 目标代码生成

中间代码生成后，我们就来到了编译器设计的最后阶段了。目标代码生成通常以编译器此前生成的中间代码、符号表及其他相关信息作为输入，输出与源程序语义等价的目标程序代码。 代码生成模块需要面向某一个特定的目标体系结构生成目标代码，这种目标体系结构可以是 X86、MIPS、ARM等，因此我们可以把目标代码生成理解成是对中间代码的翻译。对于不同体系结构，中间代码翻译成目标代码的处理方式也不同。下面我们给出一个中间代码为四元式，目标代码为MIPS指令结构的指导方案。

## 生成全局数据段

在 MIPS 汇编语言中，全局数据段使用 .data 伪指令来定义。全局数据段的定义应该包括程序中所有全局变量的声明。在生成四元式时，对于每个全局变量，需要记录其标识符、类型、变量名和初始值（如果有的话）。

生成全局数据段的步骤如下：

+ 在汇编文件中使用 .data 伪指令来定义全局数据段。

+ 对于每个全局变量，生成对应的指令。指令的格式应该根据变量的类型和初始化情况来确定。例如，对于 int 类型的变量，可以使用 .word 伪指令来分配 4 字节的空间。对于printf中的字符串，可以使用.asciiz来分配空间。

例如对于以下代码：

```
int a=2,b[10]={1,2,3,4,5,6,7,8,9,10},c;
int main(){
	printf("ssss");
}
```

我们可以生成以下MIPS代码

```
a: .word 2
b: .word 10,9,8,7,6,5,4,3,2,1,
c: .word 0
str0: .asciiz "ssss"
```

这里需要注意的是，在MIPS代码生成过程中，我们直接使用.word来给变量赋值，对于数组元素，其值的顺序与下标顺序正好相反。对于未赋初值的变量，我们默认给其赋值为0。

通过生成全局数据段，我们可以在程序运行之前为所有的全局变量分配内存空间，并在必要时将它们初始化为指定的值。这样，在程序的执行过程中，全局变量的值就可以被保存在内存中，并随时被读取和修改。

## 生成全局代码段

全局代码段包括了所有的全局函数，以及全局变量的初始化代码。在 MIPS 汇编语言中，全局代码段使用 .text 伪指令来定义。在生成四元式时，需要将每个全局函数转化为 MIPS 汇编语言的形式，并生成相应的代码段。对于全局变量的初始化代码，可以将其转化为 MIPS 汇编语言中的常量池，以便在程序运行时进行初始化。

### 寄存器分配

在不考虑优化的情况下，完全可以将所有变量都存储在内存中，寄存器仅暂存变量的值， 操作结束后将结果写入内存中的相应位置。因此，对于不考虑优化的代码生成部分来说，我们至多只需使用4个寄存器便可完成，而将最后的计算结果存入内存之中，我们可以通过循环利用的方式使用这些寄存器，例如，对于以下代码：

```
int a=1,b=2;
int c=a+b;
```

我们可以将mips代码写成这样：

```
li $t1, 1    //a=1
sw $t1, 0($sp)

li $t2, 2     //b=2
sw $t2, -4($sp)

lw $t3, 0($sp)   //c=a+b
lw $t0, -4($sp)
addu $t1, $t3, $t0
sw $t1, -8($sp)
```

我们需要在代码生成的过程中维护一个符号表，对于a=1这段代码，我们先用一个临时寄存器记录值，然后将其存入到内存的相应部分，并在符号表中记录它的位置，b=2同理，当运行到c=a+b时，我们会去符号表中找到存放a和b值的位置，并将其取出至临时寄存器中，进行计算，在计算结束后获得c的值，并继续存到相应内存中。这边需要注意的是，如果c并不是第一次被定义，那么应该从符号表中找到c最初被定义的地方，并将值存到上述地点。这些临时寄存器的值没有必要被长久保存，因此在使用后可以立即释放。

在代码生成时，我们不考虑复杂的寄存器分配方法，大家只要学会最基本的寄存器使用即可，后续在优化部分我们会着重讲述寄存器的分配方法。

### 数组的处理

不同类型数组在存储空间中的分配方案分别为：

+ 如果数组是全局数组，那么它里面的各个值依次排列在全局数据区 
+ 如果数组是函数中定义的局部数组，则数组中的值依次排列在对应函数的活动记录中 
+ 如果数组是参数数组，那么活动记录中记录的是数组的基地址

需要注意的是，为数组分配存储空间时不特别区分一维数组与二维数组：它们的区别仅仅 在于访问数组元素时的偏移计算方法有差异。 我们将与数组相关的操作分为两种：数组存取，数组地址传递。

+ 数组存取：当从某个数组中获取值或者向某个数组中存储值时，首先判断这个数组是全局数 组还是局部数组，然后获得其相对于静态数据区（或者当前活动记录基地址）的偏移，与 $gp（或$fp）求和，获得数组基地址。然后根据访问数组的位置，求出相对于数组基地址 的偏移。最后用lw或者sw访存。
+ 数组地址传递：仅出现在函数调用时。 当调用某个函数时，如果这个函数需要一个数组作 为参数，则需要把某个全局数组或者局部数组或参数数组的地址传入。若需要传入一个非参 数数组的地址，那么可以在编译时确定数组相对于静态数据区或当前活动记录的偏移，从而 与$gp或$fp求和，获得数组地址并传入。如果是参数数组，那么从活动记录中获取到的数 组值已经是数组地址，直接传入即可。如果需要传入二维数组中的某个一维数组的地址，那 么还需要加上偏移（动态计算）。

例如，对于以下代码

```
int a[2]={1,2};
a[1]=3;
```

我们可以如此操作

```
li $t1, 1  //第一行
li $t2, 0
sll $t2, $t2, 2
subu $t3, $fp, 0
subu $t3, $t3, $t2
sw $t1, ($t3)

li $t0, 2
li $t1, 1
sll $t1, $t1, 2
subu $t2, $fp, 0
subu $t2, $t2, $t1
sw $t0, ($t2)

li $t3, 3   //第二行
li $t0, 1
sll $t0, $t0, 2
subu $t1, $fp, 0
subu $t1, $t1, $t0
sw $t3, ($t1)
```

在定义数组时，我们首先找到该值对应地址的偏移量（相对于fp指针位置），在该位置赋以相应的值，并在符号表中记录。在需要使用该数组对应下标的值时，仅需要从符号表中找到其相对于fp指针的偏移量，并从内存中读出即可。当然，不要忘记在最后将值重新存到内存的相应部分。

对于在函数内访问参数数组，一般按照以下步骤执行：

1. 参数传递：

   - 在调用函数之前，将函数的参数按照约定传递给被调用函数。
   - 参数可以通过寄存器或栈进行传递。在传递参数时，需要将参数值放入相应的寄存器或栈位置。

2. 访问参数数组：

   - 如果函数的参数是以数组的形式传递的，可以使用基址寻址的方式来访问参数数组。
   - 在函数的入口处，通过将基址寄存器设置为当前栈帧指针（$fp）的值，可以轻松访问参数数组。

   

对于包含参数数组的函数

```
f(arr,len)
```

我们可以如下执行：

```
move $fp, $sp

# 访问参数数组
addiu $t0, $fp, 8       # 假设arr是相对于栈帧指针的偏移量为8
lw $t1, 0($t0)          # 加载数组元素arr[0]的值到寄存器$t1
lw $t2, 4($t0)          # 加载数组元素arr[1]的值到寄存器$t2
```

在上述示例中，我们假设参数数组`arr`相对于栈帧指针fp的偏移量为8。使用`addiu`指令将基址寄存器t0设置为fp+8，然后使用`lw`指令从相应的偏移量处加载数组元素的值到寄存器$t1、$t2等等。

通过调整偏移量和使用不同的寄存器，可以访问参数数组的不同元素。在实际的编译器实现中，还需要考虑参数的类型和对齐等因素来正确生成访问参数数组的代码。

### 短路求值

对于 if 条件分支语句的 && 短路， 可作如下变换：

```
// 变换前
if (a && b) {
	xxx
} else {
	xxx
}
// 变换后
if (a) {
	if (b) {
		xxx
    } else {
		xxx
	}
} else {
	xxx
}
```

对于 if 条件分支语句的 || 短路，可作如下变换：

```
// 变换前
if (a || b) {
	xxx
} else {
	xxx
}
// 变换后
if (a) {
	xxx
} else {
	if (b) {
		xxx
	} else {
		xxx
	}
}
```

若有 && 和 || 嵌套，可以按照符号的优先级将其拆成多个判断语句来处理。解析时遵循以下几点：

+  对 LAndExp 中每个 RelExp 进行判断：若该RelExp为真，则往后判断下一个 RelExp；若 为假，则直接跳转到当前 LAndExp 的尾部
+ 对 LOrExp 中的每个 LAndExp 进行判断：若该LAndExp为真，则直接跳转进入到 if 语句 块内部；若为假，则往后判断下一个 LAndExp
+  若所有的 LOrExp 判断完毕后还没发生跳转，说明不满足判断条件，此时跳转到 if 语句块 尾部（或 else 语句块首部）

如下图所示代码

```
if (a || ( b && c ) || d) {
	xxxx
}
```

可以修改为：

```
if (!a) {
	goto IF_OR_1
}
goto IF_BEGIN

IF_OR_1:
if (!b) {
	goto IF_OR_2
}
if (!c) {
	goto IF_OR_2
}
goto IF_BEGIN

IF_OR_2:
if (!d) {
	goto IF_OR_3
}
goto IF_BEGIN

IF_OR_3:
goto IF_END

IF_BEGIN:
	xxxx
IF_END:
```

我们一般采用如此方法进行短路求值。

### 函数调用

在四元式生成Mips汇编代码时，函数调用部分需要考虑以下几个步骤：

1. 函数调用的参数传递 在调用函数之前，需要将函数的参数压入栈中，以便函数内部可以访问到这些参数。参数的压入顺序一般是从右到左，即先将最后一个参数压入栈底，最后将第一个参数压入栈顶。
2. 保存当前函数的现场 在调用函数之前，需要将当前函数的现场保存起来，以便在函数返回时可以恢复。保存现场的主要内容包括程序计数器PC、栈指针SP和寄存器。
3. 跳转到函数入口地址 调用函数时，需要将程序计数器设置为被调用函数的入口地址。
4. 函数返回时的处理 在被调用函数返回时，需要将返回值存储在合适的寄存器中，并将调用函数的现场恢复。

例如，对于最简单的函数调用，f(1)，我们使用如下代码mips进行执行：

```
sw $ra, 0($sp)
subu $sp, $sp, 4

# PUSH:push 1
li $t1, 1
sw $t1, 0($sp)

# CALL:call f
move $fp, $sp
jal f

addiu $sp, $sp, 4
move $fp, $sp
lw $ra, 0($sp)
move $t4, $v0
```

首先第一步，将存到ra寄存器中存的返回地址存入内存，防止其被覆盖，第二步，将参数存到合适的地方以便接下来使用，第三步，调用函数，第四步，结束函数调用，恢复现场（取出函数调用前保存下来的值）并取出相应的函数返回值。

一般来说，$ra和 $fp 这两 个寄存器是函数调用时必须保存的寄存器，需要压入栈中。而其他寄存器是否需要保存，并没有标准答案。保存的寄存器越多，会带来更高的安全性，但同时造成的时间开销也会越大。具体需要保存和恢复哪种类型的寄存器，保存寄存器的数目是否要受到限制，这些需要同学们兼顾正确性和效率自行设计。

