# 目标代码生成

中间代码生成后，我们就来到了编译器设计的最后阶段了。目标代码生成通常以编译器此前生成的**中间代码**、**符号表**及其他相关信息作为输入，输出与源程序**语义等价**的目标程序代码。 代码生成模块需要面向某一个特定的目标体系结构生成目标代码，这种目标体系结构可以是 X86、MIPS、ARM 等，而且由于我们采用三端设计，因此我们可以把目标代码生成理解成是**对中间代码的翻译**。对于不同体系结构，中间代码翻译成目标代码的处理方式也不同。下面我们给出一个中间代码为四元式，目标代码为MIPS指令结构的指导方案。

## 一、MIPS 快速回顾

大家在之前的课程中应该对 MIPS 已经有所掌握了，因此这里就简单对 MIPS 相关概念做一个回顾。

### （1）基本结构

一个基本的 MIPS 程序包含 `.data` 数据段和 `.text` 代码段两部分。`.data` 段存储了全局变量，`.text` 段则存储了可执行的指令。

在 `.data` 段中声明的变量其实是一个个标签，本质是一个常数，表示改变量的地址。

在 `.text` 中，我们可以通过定义标签的方式声明函数，并通过 `jal` 以及 `j $ra` 的方式进行调用和返回。

### （2）寄存器

作为 RISC 架构的一员，MIPS 中有 32 个通用寄存器，下面对他们的作用进行简单介绍。

- `$zero`：始终为 0，可以用来减少常数 0 的使用。
- `$at`（assembly temporary)：汇编器保留寄存器，由汇编器在特定场景（通常是加载大常数）自动生成。
- `$v0 - $v1`：作为函数返回值，一般返回值只使用 `$v0`，当返回值超过 32 位时会同时使用 `$v1`。
- `$a0 - $a3`：函数调用参数，前 4 个参数通常保存在这几寄存器中，更多的参数则是压栈处理。
- `$t0 - $t7, $t8 - $t9`：临时寄存器，用于基本块内的变量，发生函数调用时不必保存。
- `$s0 - $s7`（saved）：全局寄存器，这些寄存器用于跨基本块的变量，往往需要在发生函数调用时进行保存。
- `$k0 - $k1`（keep）：系统保留寄存器，在系统发生中断时使用。
- `$sp, $fp`：栈帧寄存器，`$sp` 保存栈顶（低地址），`$fp` 保存栈底（高地址）。
- `$ra`：返回地址，`jal` 指令会自动将下一条指令的地址保存在 `$ra` 中，从而函数调用可以正确的返回。

虽然这些寄存器有自己的调用规范，可以帮助大家生成更高质量的汇编代码，但是我们实验中的代码比较简单，因此不必完全遵守，比如可以仅使用 `$sp` 完成栈的管理等。

## 二、`.data` 段生成

在 MIPS 汇编语言中，全局数据段使用 `.data` 伪指令来定义。全局数据段的定义应该包括程序中所有全局变量的声明。生成全局数据段的步骤如下：

+ 在汇编文件中使用 `.data` 伪指令来定义全局数据段。

+ 对于每个全局变量，生成对应的指令。指令的格式应该根据变量的类型和初始化情况来确定。例如，对于 `int` 类型的变量，可以使用 `.word` 伪指令来分配 4 字节的空间。对于 `printf` 中的字符串，可以使用 `.asciiz` 来分配空间。

例如，对于以下代码，我们分别有两个初始化和未初始化的全局变量，以及一个常量字符串。

```c
int a = 2;
int b[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
char c;
char d[10];

int main() {
    printf("This is a string\n");
    return 0;
}
```

那么生成的 MIPS 代码中的 `.data` 段如下。对于重复的初值，我们可以用 `<value>:<count>` 的形式来避免一长串相同的值，对于不同类型的变量，我们可以选择 `.word` 或 `.byte` 进行存储。

```assembly
.data
    a: .word 2
    b: .word 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
    c: .byte 0
    d: .byte 0:10
    .str: .asciiz "This is a string\n"
```

> MIPS `.data` 段的数据是依次存储的，因此细心的你可能会觉得这里有潜在的字节不对齐的问题。但是不用担心，在 `.data` 段汇编器是会自动完成字节对齐的操作的，不过之后在 `.text` 段使用 1 字节存储 `char` 类型变量时就需要注意变量的分配的位置了。

通过生成全局数据段，我们可以在程序运行之前为所有的全局变量分配内存空间，并在必要时将它们初始化为指定的值。这样，在程序的执行过程中，全局变量的值就可以被保存在内存中，并随时被读取和修改。

## 三、`.text` 段生成

`.text` 段中包含了程序所有的可执行指令以及用于跳转的标签。由于我们已经有了中间代码的基础，因此这里最关键的就是将中间代码中的虚拟寄存器转换为实际的寄存器，并完成内存管理。

### （1）变量分配

对于我们程序中显示声明的变量，我们都需要在栈上为其分配一段空间。在 MIPS 中，栈帧的基本结构如下。当然这是相对标准的栈帧结构，大家在实验中也可以根据自己的设计进行调整。

![](imgs/chapter07-3/stack-frame.svg)

一个函数的栈帧大小是可以在编译期通过声明的变量，以及溢出的寄存器确定的，从而它们在栈中的位置也可以确定。其中比较重要的就是对于 `$ra` 寄存器的保存，以及传参的处理。

我们的实验中，存在 `int` 和 `char` 两种类型，其中 `int` 占 4 字节，而 `char` 只占 1 字节。因此这里就涉及到了字节对齐的问题。MIPS 要求了 `lw/sw` 指令的地址必须四字节对齐，因此在为 `int` 分配空间时有可能需要添加 padding 来保证4 字节对齐。

### （2）寄存器分配

在 MIPS 这种**寄存器到寄存器**模型中，每个参与运算的值都必须被加载到寄存器中，因此在我们的 IR 中，参与运算的变量都应该对应一个寄存器，在 IR 中，我们将其称为**虚拟寄存器**。虚拟寄存器数目是无限的，但是当翻译为目标平台的汇编代码时，就需要将其映射到一组有限的寄存器中，这个过程就是**寄存器分配**。

在不考虑优化的情况下，我们完全可以将变量都保存在栈上，寄存器仅保存计算时的中间结果，计算完成后即将结果写入栈中，因此只需要固定地分配少量寄存器即可实现。例如，对于如下代码。

```c
int a = 1;
int b = 2;
int c = a + b;
```

生成的 MIPS 代码如下，可以看到每次计算都从栈中加载变量，并将结果存入对应变量。

```assembly
li $t0, 1       # a = 1
sw $t0, 0($sp)

li $t0, 2       # b = 2
sw $t0, 4($sp)

lw $t0, 0($sp)  # c = a + b
lw $t1, 4($sp)
addu $t2, $t0, $t1
sw $t1, -8($sp)
```

对于规范的寄存器分配，则需要考虑**全局寄存器**和**局部寄存器**的分配，分别对应 MIPS 中的 `s` 和 `t` 寄存器。全局寄存器对应那些生命周期跨越基本块的变量，而局部寄存器则对应基本块内的变量。对于全局寄存器分配，我们需要考虑不同变量的生命周期范围，尽可能的避免寄存器冲突。为了解决这一问题，主要由**图着色**和**线性**两种分配方式。而对于局部寄存器分配，由于基本块内部不存在分支，结构较为简单，因此使用**寄存器池**就可以实现高效的寄存器分配。

### （3）数组操作

在我们的代码生成中，主要有三个地方涉及数组：

1. 全局数组，保存在 `.data` 中，通过 `la` 加载其基地址。
2. 局部数组，在栈上分配一段连续的空间，通过 `$sp` 与偏移量访问。
3. 参数数组，传递数组基地址即可，保存时也只是保存该地址。

需要注意的是，为数组分配存储空间时不需要区分一维数组与二维数组，它们的区别仅仅在于访问数组元素时的偏移计算方法。因此数组操作的核心有两个，一个是基地址的获取，一个是偏移量的计算，二者结合起来即可完成数组所有的相关操作。例如，对于以下代码。

```c
int a[2] = { 1, 2 };
a[1] = 3;
```

我们可以生成如下的 MIPS 代码，假设 `a` 保存在 `$sp + 0` 的位置。

```assembly
li $t0, 1           # a[0] 初始化
li $t1, 0
sll $t1, $t1, 2
addu $t2, $sp, $t1
sw $t0, ($t2)

li $t0, 2           # a[1] 初始化
li $t1, 1
sll $t1, $t1, 2
addu $t2, $sp, $t1
sw $t0, ($t2)

li $t0, 3           # a[1] = 3
li $t1, 1
sll $t1, $t1, 2
addu $t2, $sp, $t1
sw $t3, ($t1)
```

对于数组作为参数的情形也是同理，只需要计算出数组的基地址，即可与整数变量一样进行传递。

### （4）函数调用

对于一个函数，除了其自身的指令外，其前后还应各有一小段代码分别进行准备和清理工作，分别是**函数序言**（Function Prologue）和**函数尾声**（Function Epilogue），其作用如下。

- 函数序言：申请所需的栈空间（修改 `$fp` 和 `$sp` 寄存器），保存使用到的全局寄存器（如果需要），以及自己的 `$ra` 寄存器。
- 函数尾声：释放栈空间，恢复全局寄存器（如果需要）以及 `$ra` 寄存器。

> 由于任意全局寄存器都可能被调用者使用，因此为了不破坏调用现场，被调用者需要保存其使用到的全局寄存器，并在结束时进行恢复。

对于函数调用者，主要有以下几个步骤。

1. 参数传递。在调用函数前，调用者需要将函数参数压入栈中。对于 MIPS，可以将前四个参数通过 `$a0 - $a3` 四个寄存器传递，但仍需要为其在栈中预留位置。参数的位置通常由参数编号和当前的 `$sp` 决定，从而被调用者可以在不知道调用者栈帧的情况下获取参数。
2. 保存现场（可选），也可以将这一任务交给被调用者的函数序言。
3. 函数跳转。通过 `jal` 或 `jalr` 指令跳转到被调用的函数，函数返回值被保存在 `$v0` 寄存器中。
4. 恢复现场（可选），也可以将这一任务交给被调用者的函数尾声。

例如，我们有如下的函数调用。

```c
void f(int a) {
    int b = a;
    return b;
}

int main() {
    f(1);
    return 0;
}
```

那么在编译时，我们可以确定其栈帧结构如下。

![](imgs/chapter07-3/stack-frame-example.svg)

因此，生成的 MIPS 如下。

```assembly
main:
    move $fp, $sp      # 初始化栈帧
    addu $sp, $sp, 12
    
    li $a0, 1          # 如果参数在栈上，则是：li $t0, 1
                       #                     sw $t0, (0)$sp
    jal f

f:
    sw   $ra, 4($sp)   # 保存自己的 $ra
    sw   $fp, 0($sp)   # 保存调用者的 $fp
    # 如有必要，保存使用到的全局寄存器
    
    move $fp, $sp      # 更新自己的 $fp
    subu $sp, $sp, 16  # 更新自己的 $sp
    
    sw   $a0, 12($sp)  # 如果参数在栈上，则是：lw $t0, (0)$fp
                       #                     sw $t0, (12)$sp
    
    lw   $t0, 12($sp)  # 返回值
    move $v0, $t0
    
    addu $sp, $sp, 16  # 恢复栈帧
    lw   $fp, 0($sp)
    lw   $ra, 4($sp)   # 恢复自己的 $ra
    
    jr   $ra           # 返回
```

这里的汇编代码是按照 MIPS 调用规范生成的，可以方便不同编译器生成的汇编代码之间进行相互调用。不过在我们的实验中只涉及大家自己生成的汇编代码，因此可以自行设计，合理即可。
