# 中间代码生成 - 自定义四元式

### （1）四元式简介

此处我们介绍一种中间代码的形式：四元式。四元式是一种形如(op, arg1, arg2, result)的指令格式，其中op是运算符，arg1和arg2是操作数，result是运算结果。例如，赋值语句 x = y + z 可以表示为：

```
+, y， z, t1
=, t1,  ,x
```

其中，+ 表示加法操作，= 表示赋值操作，y 和 z 是加法操作的两个操作数，t1 是临时变量，用于存储加法的结果，x 是赋值操作的结果。这段四元式的意思，是先把y和z的数值加和，赋值给t1，然后再把t1赋值给x。需要注意的是，在生成中间代码之前，需要为每个变量分配一个临时变量。临时变量是在中间代码生成过程中创建的，用于存储中间结果。临时变量可以采用 t1、t2、t3 等命名方式。

对于实验要求的文法来说，下面简单分析一下在生成中间代码阶段的各类语句（可自行设计）：

### （2）主函数

主函数和block块都是编译器中生成中间代码的基本单元。

主函数是整个程序的入口，通常包含全局变量的定义、函数的声明和调用以及其他一些初始化操作。在主函数中，编译器需要生成全局变量的初始化代码、函数的调用代码和程序结束时的清理代码等。Block块是一个语句块，通常由一组语句组成，可以是一个函数体、一个循环体或者一个条件语句块等。在block块中，编译器需要生成相应的控制流程代码，如条件分支和循环控制等。

对于主函数和block数据块，均可使用begin和end来描述其作用范围，大致四元式框架可描述如下：

```
main_begin,_,_,_

block_begin,_,_,_
xxxxxxx
block_end,_,_,_

block_begin,_,_,_
xxxxxxx
block_end,_,_,_

main_end,_,_,_
```

对于每个主函数与block块，均需要维护一个对应的符号表。

### （3）赋值语句

生成赋值语句的过程比较简单。假设要生成赋值语句 x = y + z，可以遵循以下步骤：

- 为加法操作分配一个临时变量 t1。
- 生成加法四元式 + y z t1。
- 生成赋值四元式 = t1 x。

对于数组元素，我们也有相应的表示方法，例如 a = num[0] 可以用如下步骤表示：

```
[], num, 0, t1 
=, t1, , a
```

对于二维数组，可将二维数组展开，当作一维数组处理即可。

### （4）条件语句

条件语句需要将条件表达式翻译成中间代码。假设条件语句为 if (x > y) then z = x + y，可以遵循以下步骤：

- 为比较操作符 >的结果分配一个临时变量 t1。
- 生成比较四元式 > x y t1（x大于y给t1赋值为1，否则赋值为0）。
- 生成条件跳转四元式 jnz t1 L（t1不为0则跳转至L处，否则继续运行）。
- 生成无条件跳转四元式 jmp M（不运行下方语句块）。
- 生成标记 L。
- 生成赋值四元式 = x + y t2。
- 生成赋值四元式 = z t2。
- 生成标记 M。

如果由if语句中存在else和elif，处理方法与上述一致，具体请同学们自行思考。

### （5）循环语句

循环语句需要使用跳转指令和标记来实现循环控制。假设循环语句为 while (x < y) do x = x + 1，可以遵循以下步骤：

- 生成标记 L。
- 为比较操作符 < 分配一个临时变量 t1。
- 生成比较四元式 < x y t1。
- 生成条件跳转四元式 beq t1 0 M(t1为0则跳转至M处，否则继续运行)。
- 生成赋值四元式 + x  1 t2。
- 生成赋值四元式 = t2 x。
- 生成无条件跳转至L。
- 生成标记M。

### （6）函数定义

函数定义也是编译器中生成中间代码的基本单元之一。函数定义描述了一个函数的参数列表、返回类型和函数体。在函数定义中，编译器需要生成函数的入口代码、参数初始化代码、局部变量的声明和初始化、函数体中的控制流程代码和函数的返回值等。我们可以模仿block和主函数的处理方法进行函数定义，例如对于如下代码

```
int f(int a,int b){
	xxxx
    return xxx;
}
```

我们可以这么定义

```
func_begin,f,_,_
para_int,a,_,_
para_int,b,_,_
xxxxxxxx
ret xxxxxx
func_end,f,_,_
```

在上述示例中，`func_begin`是函数的入口标签，`ret`指令用于将计算结果作为返回值返回给调用者，`func_end`是函数的结束标签。函数体中的局部变量可以使用临时变量来实现。

此外，函数定义中还需要维护函数的符号表，包括参数和局部变量的声明。函数调用时需要将参数传递给被调用函数，并根据函数定义的参数和返回值类型生成相应的中间代码。

### （7）函数调用

+ 在函数调用之前，需要将函数参数压入栈中。对于每个参数，可以生成一条对应的四元式，将参数值存储到一个临时变量中，并将该临时变量的地址压入栈中。例如，对于调用函数f(x, y)，可以生成以下四元式：

  ```
  =, x, _, t1    // 将x的值存储到t1中
  parm, t1, _, _ // 将t1的地址压入栈中
  =, y, _, t2    // 将y的值存储到t2中
  parm, t2, _, _ // 将t2的地址压入栈中
  ```

+ 在所有参数都被压入栈之后，可以生成一个函数调用四元式，将控制权转移给被调用函数，例如，对于调用函数f(x, y)，可以生成以下四元式：

  ```
  call, f, _, _  // 调用函数f
  ```

+ 在函数调用结束之后，需要将函数的返回值从栈中取出，并将其存储到一个临时变量中，并需要清空参数栈。

当然，这里给出的代码示例只包含了一些比较基础的语法，并没有覆盖文法中可能含有的所有情况。对于更复杂的情况，还需要同学自行思考中间代码的设计方案。

以上给出的四元式设计和中间代码规范格式都仅仅是中间代码参考架构，同学在设计过程中可以结合自己的想法对中间代码格式进行调整。中间代码的设计将直接影响到目标代码生成，所以同学在设计中间代码时一定要考虑到“如何将中间代码翻译成目标代码”，最好能具体到一些细节，以减少目标代码生成阶段中对中间代码的重构。若目标代码为MIPS指令集等汇编语言，中间代码需要尽可能向着汇编语言贴近，有些甚至可能就直接用汇编语言代替。

### （8）读入和输出

`getint()`非常简单，如遇到`b=getint()`的输入，直接使用以下四元式即可表示：

```
getint,_,_b
```

对于`printf`，可以将需要输出的字符串通过%d分割成多个字符串，对于每个%d，生成print_int中间代码，对于每一个字符串，生成print_str中间代码。

例如，对于如下代码：

```
printf("%d hello",x);
```

我们可以用如下四元式表示：

```
print_int,a[1],_,_
print_string,hello,_,_
```

