# 语法分析

### 一、语法分析概述

在上一节中，我们通过词法分析将输入的源程序解析成一个个单词。在语法分析部分，我们将对这些单词进行进一步地分析，将其建立成结构化的语法树，以便于后续的编译。

#### （一）语法树

语法树是按照给定的文法，将一个句子转化为有结构层次的树结构。**树中的每个节点都代表一个语法成分，而其子节点则代表组成该语法成分的其他语法成分，根节点为开始符号**。以下面的几条文法为例，假设Exp为开始符号（可以理解成最高级的语法成分）：

```c
左值表达式 LVal → Ident {'[' Exp ']'}
数值 Number → IntConst
基本表达式 PrimaryExp → '(' Exp ')' | LVal | Number
一元表达式 UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp
单目运算符 UnaryOp → '+' | '−' | '!'
乘除模表达式 MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp
加减表达式 AddExp → MulExp | AddExp ('+' | '−') MulExp
表达式 Exp → AddExp
```

那么对于下面这个简单的句子（其中a和b为Ident）

```c
a + (3 + b) * 2
```

我们则可以建立如下的语法树：

<img src="..\..\figure\parser_1.png" alt="parser_1" style="zoom:40%;" />

语法树展现了**从上到下的推理过程**，即我们是如何从一个语法成分推理出我们的句子（在上述例子中，从Exp推理出`a+(3+b)*2`），也就是语法树从根开始往下生长的过程；另一方面，语法树还展现了**从下到上的归约过程**，即我们是如何从一个句子不断地“合成”，最终合并成一个语法成分的（在上述例子中，从`a+(3+b)*2`最终合成Exp语法成分），也就是语法树从叶子结点向上不断合并的过程。

除此之外，不难发现，语法树中的叶子结点都是终结符（因为到终结符就无法继续拆分了），而且叶子结点从左到右刚好组成了我们输入的句子。

#### （二）语法分析的作用

上面我们介绍了给定文法时，一个句子的语法树是什么样的，以及语法树的一些特点。那么，**为什么我们要将一个简单的句子转化成如此复杂的语法树呢？**原因就在于，一个简单的句子是线性结构，不包含相应的语法结构信息，如果直接对线性的句子进行处理，是非常困难的。而语法树的层次化结构可以很好地表现语法结构，以及语法成分之间的关系；而树结构又可以很方便地利用递归等方法来进行处理，因此，将输入的源程序转化成包含语法结构的语法树，将为后续的处理带来极大的便利。

例如，对于上面例子中的表达式

```c
a + (3 + b) * 2
```

对于人来说，可以很容易地确定表达式的运算顺序。但是，从计算机角度而言，要编写一个程序仅仅根据这个线性字符串来确定运算的顺序是比较困难的，尤其是当表达式更为复杂的时候。如果我们建立了语法树，则可以很轻松地利用递归等方法来进行计算。

<img src="..\..\figure\parser_2.png" alt="parser_2" style="zoom:40%;" />

例如，在上面的例子中，我们要求表达式Exp的值（图中序号1），那么我们只需要求出AddExp（序号2）和MulExp（序号3）的值并将它们相加即可。要求MulExp（序号3）的值，我们只需要求出MulExp（序号4）和UnaryExp（序号5）的值并将它们相乘即可。同样地，要求MulExp（序号4）的值，我们只需要求出AddExp（序号6）和MulExp（序号7）的值并将它们相乘即可。对于每种语法成分的处理，如AddExp和MulExp的计算求值，我们都可以采用递归的方法很方便地实现，而且**语法树的层次结构自然保证了计算顺序的正确性**。

事实上，就像上面介绍的表达式计算，后续的编译过程也是基于语法树，利用递归等方法来进行的。因此，**语法分析的作用就是根据词法分析器解析出来的一个个单词，生成这样一棵具有层次化结构的语法树**，方便后续的编译。



### 二、语法分析器实现思路

接下来介绍实现语法分析器（Parser）的常用方法——递归下降。

#### （一）递归下降

由于树结构可以很方便的用递归来处理（例如DFS），因此，我们同样可以采用递归的方法来生成语法树。

递归下降的主要思路，就是**为每个语法成分都编写一个子程序，该子程序会调用其他的子程序来解析组成该语法成分的其他语法成分，每个子程序返回的结果都是一棵对应语法成分的子树**。具体来说，例如有以下文法：

```
A -> B '+' C
```

那么，就可以为语法成分A编写一个这样的子程序（可以暂时忽略词法分析器lexer的调用，只关注其他子程序的调用顺序）：

```
parseA() {
	B = parseB(); // 调用B的子程序，解析语法成分B
	if(lexer.type != PLUS) error();	
	lexer.next();	
	C = parseC();	// 调用C的子程序，解析语法成分C
	return new A(B,C);	// 返回由B和C组成的语法成分A
}
```

如下图所示，解析A的子程序分别调用解析B和C的子程序，得到了两棵蓝色的子树，再将两棵子树和终结符'+'合并为绿色的子树（即语法成分A的语法树）。而**在解析A的子程序中，我们并不关心解析B和C的子程序究竟做了什么，只关注其返回的结果。**

<img src="..\..\figure\parser_3.png" alt="parser_3" style="zoom:60%;" />

当然，解析A的子程序也可能被其他子程序调用，它们也不关心解析A的子程序究竟做了什么。而且解析A的子程序在调用其他子程序时，可能会再次调用解析A的子程序，例如以下文法：

```
A -> B '+' C
C -> A | '1'
```

那么，解析C的子程序就有可能调用解析A的子程序，这就是递归下降中的递归思想。

**总而言之，我们只需要为文法中的每个语法成分都编写一个子程序并确保它们之间的正确调用，最后调用开始符号的解析子程序，就可以生成整棵语法树。**

#### （二）语法分析与词法分析的配合

前面我们强调了语法分析利用词法分析解析出的一个个单词来构建语法树，因此，在编写递归下降程序的过程中，需要特别注意语法分析和词法分析的配合。如果任何一个地方错误调用了词法分析，就可能对整个语法树的构建造成影响。

为了确保语法分析和词法分析的配合，我们做出如下规定供参考：

- 一个子程序在调用其他子程序前，需要调用词法分析器来预读一个单词
- 一个子程序在退出时，需要调用词法分析器来预读一个单词

有了上述规定，就可以确保：

- 刚进入一个子程序时，词法分析器已经预读好了一个单词
- 从一个子程序返回时，词法分析器已经预读好了一个单词

因此，对于前面例子中的解析A的子程序，词法分析器的调用顺序如下：

```
parseA() {
	// 进入子程序A时，词法分析器已经预读好一个单词，从而确保了进入子程序B时，词法分析器已经预读好一个单词
	B = parseB(); 
	// 从子程序B返回时，词法分析器已经预读好了一个单词（B后面的单词），这个单词应该是'+'，检查是否符合
	if(lexer.type != PLUS) error();	// 检查'+'
	// 进入子程序C前，预读一个单词
	lexer.next();
	C = parseC();
	// 从子程序C返回时，词法分析器已经预读好了一个单词（C后面的单词，也是A后面的单词）
	// 从而保证了子程序A退出时，词法分析器已经预读好了一个单词（A后面的单词）
	return new A(B,C);
}
```

这样我们就可以确保语法分析和词法分析的协调配合。

#### （三）多产生式

如果一个语法成分只有一条产生式，那么其解析方法就是唯一确定的。但是文法中可能存在某个语法成分有多条产生式，例如

```c
语句 Stmt → LVal '=' Exp ';'
| [Exp] ';' 
| Block 
| 'if' '(' Cond ')' Stmt [ 'else' Stmt ] 
| 'for' '(' [ForStmt] ';' [Cond] ';' [ForStmt] ')' Stmt
| 'break' ';' 
| 'continue' ';' 
| 'return' [Exp] ';' 
| LVal '=' 'getint''('')'';' 
| 'printf''('FormatString{','Exp}')'';'
```

那么，**在解析Stmt的子程序中，就要考虑选择哪一条产生式进行后续的解析。**这里，我们可以考虑产生式右边的FIRST集。

假设A是某一条产生式的右部。那么A的FIRST集是一个终结符的集合，它由A能推理出的所有句子的第一个终结符组成。具体来说，对于产生式

```c
Stmt -> 'if' '(' Cond ')' Stmt [ 'else' Stmt ] 
```

很明显，该产生式的右部所能推出的任何句子的第一个终结符一定是'if'，因此，其FIRST集中只包含一个终结符'if'。

对于产生式

```c
Stmt -> Block
Block → '{' { BlockItem } '}'
```

则该Stmt产生式的右部所能推出的任何句子的第一个终结符一定是'{'，其FIRST集只包含一个终结符'{'。

对于产生式

```c
Stmt -> Exp
Exp → AddExp // EXP的FIRST={(,Number,Ident,+,-,!}
AddExp → MulExp | AddExp ('+' | '−') MulExp // AddExp的FIRST={(,Number,Ident,+,-,!}
MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp // MulExp的FIRST={(,Number,Ident,+,-,!}
UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp // UnaryExp的FIRST={(,Number,Ident,+,-,!} 其中，(,Number,Ident属于PrimaryExp的FIRST，因此也属于UnaryExp的FIRST
UnaryOp → '+' | '−' | '!'
PrimaryExp → '(' Exp ')' | LVal | Number // PrimaryExp的FIRST={(,Number,Ident}，其中Ident属于LVal的FIRST，因此也属于PrimaryExp的FIRST
LVal → Ident {'[' Exp ']'}  // LVal的FIRST={Ident}
```

按照**自底向上**的顺序，根据注释，我们可以求出该Stmt产生式右部Exp的FIRST集为$\{+,-,!,(,Ident,Number\}$（这里将Ident和Number视为终结符，因为它们是通过词法分析直接得到的单词）。

求出Stmt每条产生式的右部的FIRST集后，我们就可以根据这些FIRST集来编写解析Stmt的子程序。

```c
Stmt -> 'if' '(' Cond ')' Stmt [ 'else' Stmt ] 
```

例如，由于终结符'if'只在产生式的FIRST集中出现，因此，如果当前词法分析的单词为'if'，则只能利用这条产生式来进行解析。同样地，'for'和'break'等也是如此，据此，可以编写出下面部分的子程序：

```c
parseStmt() {
	if(lexer.type == IFTK) {
		// 用 Stmt -> 'if' '(' Cond ')' Stmt [ 'else' Stmt ] 解析
	}
	else if (lexer.type == CONTINUETK) {
		// 用 Stmt -> 'continue' ';'解析
	}
	......
}
```

需要特别注意Stmt的这几条产生式

```c
 Stmt → LVal '=' Exp ';'	// FIRST={Ident}
| LVal '=' 'getint''('')'';' 	// FIRST={Ident}
| [Exp] ';' 	// FIRST={(,Number,Ident,+,-,!}
```

其产生式右部的FIRST集存在交集$\{Ident\}$，因此，**如果当前词法分析的单词为Ident，我们就不能直接判断选择哪一条产生式进行解析。**

这里提供一种参考思路。考虑到Exp可以推理出LVal（Exp -> AddExp -> MulExp -> UnaryExp -> PrimaryExp -> LVal），因此我们**可以用Exp的解析方法来解析LVal**。如果当前单词为Ident，则

1. 首先利用调用Exp的子程序来解析出语法成分Exp，判断下一个单词是';'还是'='，如果是';'，则按第三条产生式处理，完成Stmt解析，否则转第2步，从前两条产生式中选择一条解析，.
2. 从Exp提取出LVal（该Exp一定由唯一的LVal组成），继续判断下一个单词是不是'getint'，如果是则按第二条产生式处理，否则按第一条产生式处理，完成Stmt解析

注意，如果采用Exp的解析方法来解析LVal，你需要确保输出的结果正确（即输出应该是按照LVal的解析方法来解析出来的LVal）。

对于除Stmt以外的其他语法成分的多产生式，也需要仔细考虑产生式右部的FIRST集，以编写正确的解析子程序。

#### （四）左递归文法

文法中存在左递归文法，如果直接据此编写递归下降子程序，将会导致无限递归，最终栈溢出程序崩溃。

```c
AddExp → MulExp | AddExp ('+' | '−') MulExp
MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp
```

我们需要通过改写文法来解决左递归问题。一般来说，有两种改写方法：

第一种是将左递归改为右递归。我们可以将上述两条文法改写为：

   ```c
   AddExp → MulExp | MulExp ('+' | '−') AddExp
   MulExp → UnaryExp | UnaryExp ('*' | '/' | '%') MulExp
   ```

   以解析AddExp为例，先调用MulExp的解析子程序，然后判断后面的单词是否是'+'或'-'，如果是，再递归调用解析AddExp的子程序。

第二种是改写为BNF范式。通过分析结构，不难发现AddExp本质上是由若干个MulExp组成，MulExp本质上是由若干个UnaryExp组成，因此可以将上述两条文法改写为

   ```c
   AddExp → MulExp {('+' | '−') MulExp}
   MulExp → UnaryExp {('*' | '/' | '%') UnaryExp}
   ```

   其中，{}表示其中的语法成分可以出现0到若干次。

   以解析AddExp为例，先调用MulExp的解析子程序，然后判断后面的单词是否是'+'或'-'，如果是，则再次调用MulExp的解析子程序，直至解析完MulExp后的单词不是'+'也不是'-'。

需要特别注意的是，尽管编写程序时按照改写后的文法编写，但是需要确保输出的解析次序和原来的文法一致。以第二种改写方法为例，可以在每次解析`('+' | '−') MulExp`之前，先将之前已经解析出的若干个MulExp合成一个AddExp，输出一次\<AddExp\>。

#### （五）语法错误

在语法分析阶段，需要在检测词法错误的基础上，进一步检测语法错误，包括以下几种类型。

| 错误类型        | 错误类别码 | 解释                                           | 对应文法                                                     |
| --------------- | ---------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 缺少分号        | i          | 报错行号为分号**前一个非终结符**所在行号。     | \<Stmt\>,\<ConstDecl\>及\<VarDecl\>中的';’                   |
| 缺少右小括号    | j          | 报错行号为右小括号**前一个非终结符**所在行号。 | 函数调用(\<UnaryExp\>)、函数定义(\<FuncDef\>)及\<Stmt\>中的')’ |
| 缺少右中括号’]’ | k          | 报错行号为右中括号**前一个非终结符**所在行号.  | 数组定义(\<ConstDef\>,\<VarDef\>,\<FuncFParam\>)和使用(\<LVal\>)中的']’ |
