#pragma once

#include "ast.h"
#include "lexer.h"
#include <vector>

/**
 * @brief `Parser` is a class that parses the tokens generated by the lexer, and
 * constructs an abstract syntax tree.
 */
class Parser {
public:
    /**
     * @brief Construct a new Parser object.
     * @param lexer The lexer object.
     */
    Parser(Lexer &lexer) : _lexer(lexer){};

    /**
     * @brief Parse the tokens generated by the lexer.
     * @return The abstract syntax tree.
     */
    std::unique_ptr<CompUnit> parse();

private:
    std::unique_ptr<CompUnit> _parse_comp_unit();
    std::unique_ptr<FuncDef> _parse_func_def();
    void
    _parse_func_f_params(std::vector<std::unique_ptr<Ident>> &func_f_params);
    std::unique_ptr<VarDecl> _parse_var_decl();
    std::unique_ptr<Stmt> _parse_stmt();
    std::unique_ptr<Exp> _parse_exp();
    std::unique_ptr<Exp> _parse_add_exp();
    std::unique_ptr<Exp> _parse_mul_exp();
    std::unique_ptr<Exp> _parse_unary_exp();
    std::unique_ptr<Exp> _parse_primary_exp();
    void _parse_func_r_params(std::vector<std::unique_ptr<Exp>> &func_r_params);
    std::unique_ptr<Cond> _parse_cond();
    std::unique_ptr<Ident> _parse_ident();
    std::unique_ptr<Exp> _parse_number();

    /**
     * @brief Get the next token from the lexer.
     * @note This function will pre-read the next token and store it in
     * `_pre_read`.
     */
    void _next_token() {
        _token = _pre_read;
        _lexer.next(_pre_read);
    }

    /**
     * @brief Match the current token with the expected token type, and get the
     * next token if they match.
     * @param token The current token.
     * @param expected The expected token type.
     * @note If the current token type does not match the expected token type,
     * an error will be reported.
     */
    void _match(const Token &token, Token::TokenType expected);

    /**
     * @brief Recover from a syntax error.
     * @note Skip tokens until a semicolon or EOF is encountered.
     */
    void _recover() {
        do {
            _next_token();
        } while (_token.type != Token::TK_SEMINCN &&
                 _token.type != Token::TK_EOF);
        _next_token();
    }

    // `_token` is the current token, and `_pre_read` is the next token.
    Token _token, _pre_read;

    Lexer &_lexer;
};
